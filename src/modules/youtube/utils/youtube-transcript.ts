// YouTube transcript extraction utilities

import { Logger } from '@/logging';
import { createAppError } from '@/errors';
import type {
  TranscriptSegment,
  TranscriptLanguage,
  YouTubeErrorCode,
} from '../types/youtube';

const logger = new Logger({ service: 'youtube-transcript' });

/**
 * YouTube transcript API configuration
 */
const YOUTUBE_TRANSCRIPT_BASE_URL = 'https://www.youtube.com/api/timedtext';

/**
 * YouTube transcript format types
 */
enum TranscriptFormat {
  XML = 'srv1', // Default XML format
  JSON3 = 'json3', // JSON format with styling
}

/**
 * YouTube transcript API response (JSON3 format)
 */
interface YouTubeTranscriptResponse {
  wireMagic: string;
  events: Array<{
    tStartMs: number;
    dDurationMs: number;
    segs?: Array<{
      utf8: string;
    }>;
  }>;
}

/**
 * YouTube page config regex patterns
 */
const CAPTION_TRACKS_REGEX = /"captionTracks":\s*(\[.*?\])/;
const INNERTUBE_API_KEY_REGEX = /"INNERTUBE_API_KEY":\s*"([^"]+)"/;

/**
 * Caption track from YouTube page
 */
interface CaptionTrack {
  baseUrl: string;
  name: {
    simpleText: string;
  };
  vssId: string;
  languageCode: string;
  kind?: string;
  isTranslatable?: boolean;
}

/**
 * YouTube transcript extractor class
 */
export class YouTubeTranscriptExtractor {
  /**
   * Get available transcript languages for a video
   */
  async getAvailableLanguages(videoId: string): Promise<TranscriptLanguage[]> {
    try {
      logger.info('Fetching available transcript languages', { videoId });

      // Fetch YouTube video page
      const videoUrl = `https://www.youtube.com/watch?v=${videoId}`;
      const response = await fetch(videoUrl, {
        headers: {
          'Accept-Language': 'en-US,en;q=0.9',
          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
        },
      });

      if (!response.ok) {
        throw new Error(`Failed to fetch video page: ${response.status}`);
      }

      const html = await response.text();

      // Extract caption tracks from page
      const captionTracksMatch = html.match(CAPTION_TRACKS_REGEX);
      if (!captionTracksMatch) {
        logger.info('No captions found for video', { videoId });
        return [];
      }

      const captionTracks: CaptionTrack[] = JSON.parse(captionTracksMatch[1]);
      
      // Transform to our format
      const languages: TranscriptLanguage[] = captionTracks.map(track => ({
        code: track.languageCode,
        name: track.name.simpleText,
        isAutoGenerated: track.kind === 'asr',
        isTranslatable: track.isTranslatable !== false,
      }));

      logger.info('Found transcript languages', {
        videoId,
        count: languages.length,
        languages: languages.map(l => l.code),
      });

      return languages;
    } catch (error) {
      logger.error('Failed to get available languages', error as Error, { videoId });
      throw createAppError(
        YouTubeErrorCode.API_ERROR,
        'Failed to fetch available transcript languages',
        { videoId, error: (error as Error).message }
      );
    }
  }

  /**
   * Extract transcript for a video in specified language
   */
  async extractTranscript(
    videoId: string,
    languageCode: string = 'en'
  ): Promise<{
    segments: TranscriptSegment[];
    language: TranscriptLanguage;
    totalDuration: number;
  }> {
    try {
      logger.info('Extracting transcript', { videoId, languageCode });

      // First, get available languages to find the caption URL
      const languages = await this.getAvailableLanguages(videoId);
      
      if (languages.length === 0) {
        throw createAppError(
          YouTubeErrorCode.API_ERROR,
          'No transcripts available for this video',
          { videoId }
        );
      }

      // Find the requested language or fallback to first available
      let selectedLanguage = languages.find(l => l.code === languageCode);
      if (!selectedLanguage) {
        logger.warn('Requested language not found, using first available', {
          videoId,
          requested: languageCode,
          available: languages.map(l => l.code),
        });
        selectedLanguage = languages[0];
      }

      // Fetch the transcript
      const transcript = await this.fetchTranscriptData(videoId, selectedLanguage.code);

      return {
        segments: transcript.segments,
        language: selectedLanguage,
        totalDuration: transcript.totalDuration,
      };
    } catch (error) {
      if (error instanceof Error && error.name === 'AppError') {
        throw error;
      }
      
      logger.error('Failed to extract transcript', error as Error, {
        videoId,
        languageCode,
      });
      
      throw createAppError(
        YouTubeErrorCode.API_ERROR,
        'Failed to extract transcript',
        { videoId, languageCode, error: (error as Error).message }
      );
    }
  }

  /**
   * Fetch transcript data from YouTube
   */
  private async fetchTranscriptData(
    videoId: string,
    languageCode: string
  ): Promise<{
    segments: TranscriptSegment[];
    totalDuration: number;
  }> {
    // Build transcript API URL
    const params = new URLSearchParams({
      v: videoId,
      lang: languageCode,
      fmt: TranscriptFormat.JSON3,
      xorb: '2',
      xobt: '3',
      xovt: '3',
      tlang: languageCode,
    });

    const url = `${YOUTUBE_TRANSCRIPT_BASE_URL}?${params}`;

    const response = await fetch(url, {
      headers: {
        'Accept': 'application/json',
        'Accept-Language': 'en-US,en;q=0.9',
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
      },
    });

    if (!response.ok) {
      if (response.status === 404) {
        throw createAppError(
          YouTubeErrorCode.API_ERROR,
          'Transcript not found for the specified language',
          { videoId, languageCode }
        );
      }
      throw new Error(`Transcript API error: ${response.status}`);
    }

    const data: YouTubeTranscriptResponse = await response.json();

    // Parse transcript segments
    const segments: TranscriptSegment[] = [];
    let totalDuration = 0;

    for (const event of data.events) {
      if (event.segs && event.segs.length > 0) {
        const text = event.segs.map(seg => seg.utf8).join('');
        const start = event.tStartMs / 1000; // Convert to seconds
        const duration = event.dDurationMs / 1000; // Convert to seconds

        segments.push({
          start,
          duration,
          text: text.trim(),
        });

        const endTime = start + duration;
        if (endTime > totalDuration) {
          totalDuration = endTime;
        }
      }
    }

    logger.info('Transcript extracted successfully', {
      videoId,
      languageCode,
      segmentCount: segments.length,
      totalDuration,
    });

    return { segments, totalDuration };
  }

  /**
   * Alternative method using YouTube Data API (requires API key)
   * Note: YouTube Data API v3 doesn't directly provide transcripts,
   * but this method can be used to get video details
   */
  async getVideoDetails(videoId: string, apiKey: string): Promise<any> {
    const params = new URLSearchParams({
      part: 'snippet,contentDetails',
      id: videoId,
      key: apiKey,
    });

    const url = `https://www.googleapis.com/youtube/v3/videos?${params}`;
    const response = await fetch(url);

    if (!response.ok) {
      throw new Error(`YouTube API error: ${response.status}`);
    }

    return response.json();
  }
}

/**
 * Utility functions for transcript processing
 */
export const transcriptUtils = {
  /**
   * Search for text in transcript segments
   */
  searchInTranscript(
    segments: TranscriptSegment[],
    searchTerm: string,
    caseSensitive: boolean = false
  ): Array<TranscriptSegment & { index: number }> {
    const term = caseSensitive ? searchTerm : searchTerm.toLowerCase();
    
    return segments
      .map((segment, index) => ({ ...segment, index }))
      .filter(segment => {
        const text = caseSensitive ? segment.text : segment.text.toLowerCase();
        return text.includes(term);
      });
  },

  /**
   * Get transcript segment at specific timestamp
   */
  getSegmentAtTimestamp(
    segments: TranscriptSegment[],
    timestamp: number
  ): TranscriptSegment | null {
    return segments.find(segment => 
      timestamp >= segment.start && 
      timestamp < (segment.start + segment.duration)
    ) || null;
  },

  /**
   * Merge consecutive segments with small gaps
   */
  mergeSegments(
    segments: TranscriptSegment[],
    maxGap: number = 0.5
  ): TranscriptSegment[] {
    if (segments.length === 0) return [];

    const merged: TranscriptSegment[] = [];
    let current = { ...segments[0] };

    for (let i = 1; i < segments.length; i++) {
      const next = segments[i];
      const gap = next.start - (current.start + current.duration);

      if (gap <= maxGap) {
        // Merge segments
        current.duration = (next.start + next.duration) - current.start;
        current.text += ' ' + next.text;
      } else {
        // Save current and start new
        merged.push(current);
        current = { ...next };
      }
    }

    merged.push(current);
    return merged;
  },

  /**
   * Calculate reading time for transcript
   */
  calculateReadingTime(
    segments: TranscriptSegment[],
    wordsPerMinute: number = 200
  ): number {
    const totalWords = segments.reduce((sum, segment) => {
      return sum + segment.text.split(/\s+/).length;
    }, 0);

    return Math.ceil(totalWords / wordsPerMinute);
  },
};

// Export singleton instance
export const transcriptExtractor = new YouTubeTranscriptExtractor();