// Integration tests for YouTube transcript extraction endpoint

import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import request from 'supertest';
import { TestDatabaseManager } from '@/testing/database-manager';

const BASE_URL = process.env.SUPABASE_URL || 'http://localhost:54321';
const testDb = new TestDatabaseManager();

describe('YouTube Transcript Extraction Integration', () => {
  // Test videos with known transcripts
  const TEST_VIDEOS = {
    englishWithCaptions: {
      id: 'dQw4w9WgXcQ', // Rick Astley - has captions
      expectedLanguages: ['en'],
    },
    multiLanguage: {
      id: 'JGwWNGJdvx8', // Ed Sheeran - Shape of You (has multiple languages)
      expectedLanguages: ['en'],
    },
    noTranscripts: {
      id: 'invalid12345',
    },
  };

  beforeAll(async () => {
    await testDb.setup();
    
    // Ensure test videos exist in database
    const supabase = testDb.getServiceClient();
    
    for (const [key, video] of Object.entries(TEST_VIDEOS)) {
      if (video.id && video.id !== 'invalid12345') {
        await supabase
          .from('youtube_videos')
          .upsert({
            video_id: video.id,
            title: `Test Video ${key}`,
            channel_id: 'test_channel',
            channel_name: 'Test Channel',
            published_at: new Date().toISOString(),
            duration_seconds: 180,
          }, {
            onConflict: 'video_id',
          });
      }
    }
  });

  afterAll(async () => {
    await testDb.teardown();
  });

  describe('POST /v1/youtube/transcript/extract', () => {
    describe('Successful transcript extraction', () => {
      it('should extract transcript for a video with captions', async () => {
        const response = await request(`${BASE_URL}/functions/v1`)
          .post('/youtube_extract-transcript')
          .send({
            videoId: TEST_VIDEOS.englishWithCaptions.id,
          })
          .expect(200);

        expect(response.body).toMatchObject({
          success: true,
          data: {
            videoId: TEST_VIDEOS.englishWithCaptions.id,
            language: expect.any(String),
            languageName: expect.any(String),
            isAutoGenerated: expect.any(Boolean),
            segments: expect.any(Array),
            totalDuration: expect.any(Number),
            segmentCount: expect.any(Number),
            characterCount: expect.any(Number),
            processedAt: expect.any(String),
          },
        });

        // Verify segments structure
        const { segments } = response.body.data;
        expect(segments.length).toBeGreaterThan(0);
        
        const firstSegment = segments[0];
        expect(firstSegment).toHaveProperty('start');
        expect(firstSegment).toHaveProperty('duration');
        expect(firstSegment).toHaveProperty('text');
        expect(typeof firstSegment.start).toBe('number');
        expect(typeof firstSegment.duration).toBe('number');
        expect(typeof firstSegment.text).toBe('string');
      });

      it('should extract transcript with specific language', async () => {
        const response = await request(`${BASE_URL}/functions/v1`)
          .post('/youtube_extract-transcript')
          .send({
            videoId: TEST_VIDEOS.englishWithCaptions.id,
            language: 'en',
          })
          .expect(200);

        expect(response.body.success).toBe(true);
        expect(response.body.data.language).toBe('en');
      });

      it('should return cached transcript on second request', async () => {
        // First request
        const response1 = await request(`${BASE_URL}/functions/v1`)
          .post('/youtube_extract-transcript')
          .send({
            videoId: TEST_VIDEOS.englishWithCaptions.id,
            language: 'en',
          })
          .expect(200);

        // Second request (should be cached)
        const response2 = await request(`${BASE_URL}/functions/v1`)
          .post('/youtube_extract-transcript')
          .send({
            videoId: TEST_VIDEOS.englishWithCaptions.id,
            language: 'en',
          })
          .expect(200);

        // Compare responses (should be identical except processedAt)
        expect(response2.body.data.segments).toEqual(response1.body.data.segments);
        expect(response2.body.data.totalDuration).toBe(response1.body.data.totalDuration);
      });

      it('should handle video ID without dashes', async () => {
        const response = await request(`${BASE_URL}/functions/v1`)
          .post('/youtube_extract-transcript')
          .send({
            videoId: TEST_VIDEOS.englishWithCaptions.id,
          })
          .expect(200);

        expect(response.body.success).toBe(true);
        expect(response.body.data.videoId).toBe(TEST_VIDEOS.englishWithCaptions.id);
      });
    });

    describe('Error handling', () => {
      it('should return 400 for missing videoId', async () => {
        const response = await request(`${BASE_URL}/functions/v1`)
          .post('/youtube_extract-transcript')
          .send({})
          .expect(400);

        expect(response.body).toMatchObject({
          success: false,
          error: {
            code: 'VALIDATION_ERROR',
            message: expect.any(String),
            details: expect.arrayContaining(['videoId is required and must be a string']),
          },
        });
      });

      it('should return 400 for invalid video ID format', async () => {
        const invalidIds = [
          'abc', // Too short
          'abcdefghijklmnop', // Too long
          'abc def ghi', // Contains spaces
          'abc@def#ghi', // Invalid characters
        ];

        for (const videoId of invalidIds) {
          const response = await request(`${BASE_URL}/functions/v1`)
            .post('/youtube_extract-transcript')
            .send({ videoId })
            .expect(400);

          expect(response.body.error.code).toBe('VALIDATION_ERROR');
          expect(response.body.error.details).toContain('Invalid video ID format');
        }
      });

      it('should return 400 for invalid language code', async () => {
        const invalidLanguages = [
          'english', // Should be 'en'
          'e', // Too short
          'EN', // Should be lowercase
          '123', // Not a language code
        ];

        for (const language of invalidLanguages) {
          const response = await request(`${BASE_URL}/functions/v1`)
            .post('/youtube_extract-transcript')
            .send({
              videoId: TEST_VIDEOS.englishWithCaptions.id,
              language,
            })
            .expect(400);

          expect(response.body.error.code).toBe('VALIDATION_ERROR');
        }
      });

      it('should return 404 for video without transcripts', async () => {
        const response = await request(`${BASE_URL}/functions/v1`)
          .post('/youtube_extract-transcript')
          .send({
            videoId: TEST_VIDEOS.noTranscripts.id,
          })
          .expect(404);

        expect(response.body).toMatchObject({
          success: false,
          error: {
            code: expect.stringMatching(/NO_TRANSCRIPTS|VIDEO_NOT_FOUND/),
            message: expect.any(String),
          },
        });
      });

      it('should handle malformed JSON', async () => {
        const response = await request(`${BASE_URL}/functions/v1`)
          .post('/youtube_extract-transcript')
          .set('Content-Type', 'application/json')
          .send('{"invalid json')
          .expect(400);

        expect(response.body.error.code).toBe('INVALID_REQUEST');
      });

      it('should return 405 for non-POST methods', async () => {
        const methods = ['GET', 'PUT', 'DELETE', 'PATCH'];

        for (const method of methods) {
          const response = await request(`${BASE_URL}/functions/v1`)
            [method.toLowerCase()]('/youtube_extract-transcript')
            .expect(405);

          expect(response.headers['allow']).toBe('POST, OPTIONS');
        }
      });
    });

    describe('Language handling', () => {
      it('should fallback to available language if requested not found', async () => {
        const response = await request(`${BASE_URL}/functions/v1`)
          .post('/youtube_extract-transcript')
          .send({
            videoId: TEST_VIDEOS.englishWithCaptions.id,
            language: 'ja', // Japanese might not be available
          })
          .expect(200);

        expect(response.body.success).toBe(true);
        // Should fallback to available language (likely 'en')
        expect(response.body.data.language).toBeDefined();
        expect(response.body.data.segments.length).toBeGreaterThan(0);
      });

      it('should handle language variants (e.g., en-US)', async () => {
        const response = await request(`${BASE_URL}/functions/v1`)
          .post('/youtube_extract-transcript')
          .send({
            videoId: TEST_VIDEOS.englishWithCaptions.id,
            language: 'en-US',
          });

        // Should either succeed or return validation error
        if (response.status === 200) {
          expect(response.body.success).toBe(true);
        } else {
          expect(response.status).toBe(400);
          expect(response.body.error.code).toBe('VALIDATION_ERROR');
        }
      });
    });

    describe('Transcript content validation', () => {
      it('should have properly ordered segments', async () => {
        const response = await request(`${BASE_URL}/functions/v1`)
          .post('/youtube_extract-transcript')
          .send({
            videoId: TEST_VIDEOS.englishWithCaptions.id,
          })
          .expect(200);

        const { segments } = response.body.data;
        
        // Check segments are ordered by start time
        for (let i = 1; i < segments.length; i++) {
          expect(segments[i].start).toBeGreaterThanOrEqual(segments[i - 1].start);
        }
      });

      it('should have non-empty text in segments', async () => {
        const response = await request(`${BASE_URL}/functions/v1`)
          .post('/youtube_extract-transcript')
          .send({
            videoId: TEST_VIDEOS.englishWithCaptions.id,
          })
          .expect(200);

        const { segments } = response.body.data;
        
        // All segments should have text
        segments.forEach((segment: any) => {
          expect(segment.text).toBeTruthy();
          expect(segment.text.length).toBeGreaterThan(0);
        });
      });

      it('should calculate correct metadata', async () => {
        const response = await request(`${BASE_URL}/functions/v1`)
          .post('/youtube_extract-transcript')
          .send({
            videoId: TEST_VIDEOS.englishWithCaptions.id,
          })
          .expect(200);

        const { segments, segmentCount, characterCount, totalDuration } = response.body.data;
        
        // Verify segment count
        expect(segmentCount).toBe(segments.length);
        
        // Verify character count
        const calculatedCharCount = segments.reduce(
          (sum: number, seg: any) => sum + seg.text.length,
          0
        );
        expect(characterCount).toBe(calculatedCharCount);
        
        // Verify total duration makes sense
        expect(totalDuration).toBeGreaterThan(0);
        expect(totalDuration).toBeLessThan(3600); // Less than 1 hour for test video
      });
    });

    describe('Security', () => {
      it('should include security headers', async () => {
        const response = await request(`${BASE_URL}/functions/v1`)
          .post('/youtube_extract-transcript')
          .send({
            videoId: TEST_VIDEOS.englishWithCaptions.id,
          })
          .expect(200);

        expect(response.headers).toMatchObject({
          'x-content-type-options': 'nosniff',
          'x-frame-options': 'DENY',
          'x-xss-protection': '1; mode=block',
          'strict-transport-security': expect.stringContaining('max-age='),
          'cache-control': 'no-cache, no-store, must-revalidate',
        });
      });

      it('should handle CORS preflight requests', async () => {
        const response = await request(`${BASE_URL}/functions/v1`)
          .options('/youtube_extract-transcript')
          .set('Origin', 'http://localhost:3000')
          .set('Access-Control-Request-Method', 'POST')
          .expect(200);

        expect(response.headers).toHaveProperty('access-control-allow-origin');
        expect(response.headers).toHaveProperty('access-control-allow-methods');
      });
    });

    describe('Performance', () => {
      it('should respond within acceptable time', async () => {
        const startTime = Date.now();

        await request(`${BASE_URL}/functions/v1`)
          .post('/youtube_extract-transcript')
          .send({
            videoId: TEST_VIDEOS.englishWithCaptions.id,
          })
          .expect(200);

        const duration = Date.now() - startTime;
        expect(duration).toBeLessThan(10000); // 10 seconds max for first fetch
      });

      it('cached responses should be very fast', async () => {
        // Ensure transcript is cached
        await request(`${BASE_URL}/functions/v1`)
          .post('/youtube_extract-transcript')
          .send({
            videoId: TEST_VIDEOS.englishWithCaptions.id,
            language: 'en',
          });

        // Measure cached response time
        const startTime = Date.now();

        await request(`${BASE_URL}/functions/v1`)
          .post('/youtube_extract-transcript')
          .send({
            videoId: TEST_VIDEOS.englishWithCaptions.id,
            language: 'en',
          })
          .expect(200);

        const duration = Date.now() - startTime;
        expect(duration).toBeLessThan(500); // 500ms for cached response
      });
    });
  });
});