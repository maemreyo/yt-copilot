// YouTube transcript extraction endpoint

import { serve } from 'std/http/server.ts';
import { createClient } from '@supabase/supabase-js';
import { corsHeaders } from '@/cors';

/**
 * Request interface
 */
interface ExtractTranscriptRequest {
  videoId: string;
  language?: string; // ISO 639-1 code
  options?: {
    preferAutoGenerated?: boolean;
    includeTimestamps?: boolean;
  };
}

/**
 * Response interface
 */
interface ExtractTranscriptResponse {
  success: boolean;
  data?: {
    videoId: string;
    language: string;
    languageName: string;
    isAutoGenerated: boolean;
    segments: Array<{
      start: number;
      duration: number;
      text: string;
    }>;
    totalDuration: number;
    segmentCount: number;
    characterCount: number;
    processedAt: string;
  };
  error?: {
    code: string;
    message: string;
    details?: any;
  };
}

/**
 * Import security headers from shared utilities
 */
import { securityHeaders } from '@/shared-security';

/**
 * Caption track interface
 */
interface CaptionTrack {
  baseUrl: string;
  name: { simpleText: string };
  vssId: string;
  languageCode: string;
  kind?: string;
  isTranslatable?: boolean;
}

/**
 * Import validation utilities
 */
import { validateRequestBody, ValidationSchema } from '@/shared-validation';

/**
 * Validate YouTube video ID
 */
function validateVideoId(
  value: unknown,
): { isValid: boolean; errors: string[] } {
  if (typeof value !== 'string') {
    return { isValid: false, errors: ['Must be a string'] };
  }

  if (!/^[a-zA-Z0-9_-]{11}$/.test(value)) {
    return { isValid: false, errors: ['Invalid YouTube video ID format'] };
  }

  return { isValid: true, errors: [] };
}

/**
 * Validate language code
 */
function validateLanguageCode(
  value: unknown,
): { isValid: boolean; errors: string[] } {
  if (typeof value !== 'string') {
    return { isValid: false, errors: ['Must be a string'] };
  }

  if (!/^[a-z]{2}(-[A-Z]{2})?$/.test(value)) {
    return {
      isValid: false,
      errors: ['Must be a valid ISO 639-1 code (e.g., en, vi)'],
    };
  }

  return { isValid: true, errors: [] };
}

/**
 * Request validation schema
 */
const transcriptRequestSchema: ValidationSchema<ExtractTranscriptRequest> = {
  videoId: {
    required: true,
    type: 'string',
    validate: validateVideoId,
  },
  language: {
    required: false,
    type: 'string',
    validate: validateLanguageCode,
  },
  options: {
    required: false,
    type: 'object',
  },
};

/**
 * Request validation
 */
function validateRequest(data: any): { isValid: boolean; errors: string[] } {
  const result = validateRequestBody<ExtractTranscriptRequest>(
    data,
    transcriptRequestSchema,
  );
  return {
    isValid: result.isValid,
    errors: result.errors,
  };
}

/**
 * Get cached transcript from database
 */
async function getCachedTranscript(
  supabase: any,
  videoId: string,
  language: string,
): Promise<any | null> {
  try {
    // First get the video record
    const { data: video, error: videoError } = await supabase
      .from('youtube_videos')
      .select('id')
      .eq('video_id', videoId)
      .single();

    if (videoError || !video) {
      return null;
    }

    // Then get the transcript
    const { data: transcript, error } = await supabase
      .from('video_transcripts')
      .select('*')
      .eq('video_id', video.id)
      .eq('language_code', language)
      .single();

    if (error || !transcript) {
      return null;
    }

    // Check if cache is still valid (7 days for transcripts)
    const createdAt = new Date(transcript.created_at);
    const now = new Date();
    const daysSinceCreation = (now.getTime() - createdAt.getTime()) /
      (1000 * 60 * 60 * 24);

    if (daysSinceCreation > 7) {
      return null; // Cache expired
    }

    return transcript;
  } catch (error) {
    console.error('Cache lookup failed:', error);
    return null;
  }
}

/**
 * Save transcript to database
 */
async function saveTranscript(
  supabase: any,
  videoId: string,
  transcript: any,
): Promise<void> {
  try {
    // First ensure video exists
    const { data: video, error: videoError } = await supabase
      .from('youtube_videos')
      .select('id')
      .eq('video_id', videoId)
      .single();

    if (videoError || !video) {
      console.error('Video not found in database:', videoId);
      return;
    }

    // Calculate metadata
    const characterCount = transcript.segments.reduce(
      (sum: number, seg: any) => sum + seg.text.length,
      0,
    );

    // Save transcript
    const { error } = await supabase
      .from('video_transcripts')
      .upsert({
        video_id: video.id,
        language_code: transcript.language,
        language_name: transcript.languageName,
        is_auto_generated: transcript.isAutoGenerated,
        is_translatable: true,
        segments: transcript.segments,
        total_duration_seconds: Math.ceil(transcript.totalDuration),
        segment_count: transcript.segments.length,
        character_count: characterCount,
      }, {
        onConflict: 'video_id,language_code',
      });

    if (error) {
      console.error('Failed to save transcript:', error);
    }
  } catch (error) {
    console.error('Save transcript failed:', error);
  }
}

/**
 * Extract available languages from YouTube page
 */
async function getAvailableLanguages(videoId: string): Promise<any[]> {
  const videoUrl = `https://www.youtube.com/watch?v=${videoId}`;
  const response = await fetch(videoUrl, {
    headers: {
      'Accept-Language': 'en-US,en;q=0.9',
      'User-Agent':
        'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
    },
  });

  if (!response.ok) {
    throw new Error(`Failed to fetch video page: ${response.status}`);
  }

  const html = await response.text();

  // Extract caption tracks
  const captionTracksMatch = html.match(/"captionTracks":\s*(\[.*?\])/);
  if (!captionTracksMatch) {
    return [];
  }

  const captionTracks: CaptionTrack[] = JSON.parse(captionTracksMatch[1]);

  return captionTracks.map((track) => ({
    code: track.languageCode,
    name: track.name.simpleText,
    isAutoGenerated: track.kind === 'asr',
    baseUrl: track.baseUrl,
  }));
}

/**
 * Fetch transcript from YouTube
 */
async function fetchTranscript(
  videoId: string,
  languageCode: string,
): Promise<any> {
  // Get available languages first
  const languages = await getAvailableLanguages(videoId);

  if (languages.length === 0) {
    throw new Error('No transcripts available for this video');
  }

  // Find requested language
  let selectedLanguage = languages.find((l) => l.code === languageCode);
  if (!selectedLanguage) {
    // Fallback to first available
    selectedLanguage = languages[0];
  }

  // Fetch transcript data
  const transcriptUrl = new URL(selectedLanguage.baseUrl);
  transcriptUrl.searchParams.set('fmt', 'json3');

  const response = await fetch(transcriptUrl.toString(), {
    headers: {
      'Accept': 'application/json',
      'User-Agent':
        'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
    },
  });

  if (!response.ok) {
    throw new Error(`Failed to fetch transcript: ${response.status}`);
  }

  const data = await response.json();

  // Parse segments
  const segments: any[] = [];
  let totalDuration = 0;

  if (data.events) {
    for (const event of data.events) {
      if (event.segs && event.segs.length > 0) {
        const text = event.segs.map((seg: any) => seg.utf8).join('');
        const start = (event.tStartMs || 0) / 1000;
        const duration = (event.dDurationMs || 0) / 1000;

        if (text.trim()) {
          segments.push({
            start: Math.round(start * 100) / 100,
            duration: Math.round(duration * 100) / 100,
            text: text.trim(),
          });

          const endTime = start + duration;
          if (endTime > totalDuration) {
            totalDuration = endTime;
          }
        }
      }
    }
  }

  return {
    language: selectedLanguage.code,
    languageName: selectedLanguage.name,
    isAutoGenerated: selectedLanguage.isAutoGenerated,
    segments,
    totalDuration,
  };
}

/**
 * Import additional shared utilities
 */
import {
  createCorsErrorResponse,
  createCorsResponse,
  createCorsSuccessResponse,
} from '@/cors';
import {
  AppError,
  createAppError,
  ErrorType,
  handleUnknownError,
} from '@/shared-errors';

/**
 * Main serve function
 */
serve(async (req) => {
  // Generate a request ID for tracking
  const requestId = crypto.randomUUID();

  // Handle CORS preflight
  if (req.method === 'OPTIONS') {
    return createCorsResponse();
  }

  // Only allow POST requests
  if (req.method !== 'POST') {
    return createCorsErrorResponse(
      'Only POST method is allowed',
      405,
      requestId,
      {
        code: 'METHOD_NOT_ALLOWED',
        allowedMethods: ['POST'],
      },
    );
  }

  try {
    // Parse request body
    let requestData: ExtractTranscriptRequest;
    try {
      requestData = await req.json();
    } catch (error) {
      throw createAppError(
        ErrorType.VALIDATION_ERROR,
        'Invalid JSON in request body',
        { code: 'INVALID_REQUEST' },
        requestId,
      );
    }

    // Validate request
    const validation = validateRequest(requestData);
    if (!validation.isValid) {
      throw createAppError(
        ErrorType.VALIDATION_ERROR,
        'Invalid request parameters',
        {
          code: 'VALIDATION_ERROR',
          details: validation.errors,
        },
        requestId,
      );
    }

    const videoId = requestData.videoId;
    const language = requestData.language || 'en';

    // Initialize Supabase client
    const supabaseUrl = Deno.env.get('SUPABASE_URL');
    const supabaseServiceKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY');

    if (!supabaseUrl || !supabaseServiceKey) {
      throw new Error('Supabase configuration missing');
    }

    const supabase = createClient(supabaseUrl, supabaseServiceKey);

    // Check cache first
    const cached = await getCachedTranscript(supabase, videoId, language);
    if (cached) {
      console.log('Returning cached transcript');

      return createCorsSuccessResponse(
        {
          success: true,
          data: {
            videoId,
            language: cached.language_code,
            languageName: cached.language_name,
            isAutoGenerated: cached.is_auto_generated,
            segments: cached.segments,
            totalDuration: cached.total_duration_seconds,
            segmentCount: cached.segment_count,
            characterCount: cached.character_count,
            processedAt: cached.created_at,
          },
        } as ExtractTranscriptResponse,
        200,
        requestId,
      );
    }

    // Fetch transcript from YouTube
    console.log('Fetching transcript from YouTube');
    const transcript = await fetchTranscript(videoId, language);

    // Calculate character count
    const characterCount = transcript.segments.reduce(
      (sum: number, seg: any) => sum + seg.text.length,
      0,
    );

    // Save to cache
    await saveTranscript(supabase, videoId, transcript);

    // Return response
    return createCorsSuccessResponse(
      {
        success: true,
        data: {
          videoId,
          language: transcript.language,
          languageName: transcript.languageName,
          isAutoGenerated: transcript.isAutoGenerated,
          segments: transcript.segments,
          totalDuration: transcript.totalDuration,
          segmentCount: transcript.segments.length,
          characterCount,
          processedAt: new Date().toISOString(),
        },
      } as ExtractTranscriptResponse,
      200,
      requestId,
    );
  } catch (error) {
    console.error('Request failed:', error);

    // If it's already an AppError, return it directly
    if (error instanceof AppError) {
      return error.toHttpResponse();
    }

    // Map specific error messages to appropriate error types
    if (error instanceof Error) {
      if (error.message.includes('No transcripts available')) {
        return createCorsErrorResponse(
          'No transcripts available for this video',
          404,
          requestId,
          { code: 'NO_TRANSCRIPTS' },
        );
      }

      if (error.message.includes('Failed to fetch video page')) {
        return createCorsErrorResponse(
          'Video not found or is private',
          404,
          requestId,
          { code: 'VIDEO_NOT_FOUND' },
        );
      }

      if (error.message.includes('Failed to fetch transcript')) {
        return createCorsErrorResponse(
          'Failed to fetch transcript from YouTube',
          502,
          requestId,
          { code: 'TRANSCRIPT_FETCH_FAILED' },
        );
      }
    }

    // For any other unknown errors
    const appError = handleUnknownError(error, requestId);
    return appError.toHttpResponse();
  }
});
