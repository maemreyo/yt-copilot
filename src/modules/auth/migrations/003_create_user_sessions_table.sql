/**
 * User Sessions Table
 * 
 * Supports the SessionManager from auth-middleware.ts
 * Provides persistent session storage with Redis cache fallback
 * 
 * @depends: 001_create_profiles_table
 * @description: User session management table for persistent login sessions
 */

-- Create user sessions table
CREATE TABLE IF NOT EXISTS public.user_sessions (
  id TEXT PRIMARY KEY,                         -- Session ID (generated by SessionManager)
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  user_email TEXT NOT NULL,                    -- Denormalized for faster queries
  user_role TEXT NOT NULL DEFAULT 'user',     -- Denormalized user role
  
  -- Session data
  permissions JSONB DEFAULT '[]',              -- User permissions array
  metadata JSONB DEFAULT '{}',                 -- Additional session metadata
  
  -- Session lifecycle
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  expires_at TIMESTAMPTZ NOT NULL,            -- Session expiration time
  last_accessed_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  
  -- Security tracking
  ip_address INET,                             -- IP address from request
  user_agent TEXT,                             -- User agent string
  
  -- Session state
  is_active BOOLEAN NOT NULL DEFAULT true,     -- Session active state
  revoked_at TIMESTAMPTZ,                     -- When session was revoked
  revoked_reason TEXT,                         -- Reason for revocation
  
  -- Constraints
  CONSTRAINT user_sessions_user_role_check CHECK (user_role IN ('admin', 'user', 'readonly', 'api')),
  CONSTRAINT user_sessions_expires_check CHECK (expires_at > created_at),
  CONSTRAINT user_sessions_revoked_check CHECK (
    (is_active = true AND revoked_at IS NULL) OR 
    (is_active = false AND revoked_at IS NOT NULL)
  )
);

-- Create indexes for efficient queries
CREATE INDEX user_sessions_user_id_idx ON public.user_sessions(user_id);
CREATE INDEX user_sessions_user_email_idx ON public.user_sessions(user_email);
CREATE INDEX user_sessions_expires_at_idx ON public.user_sessions(expires_at);
CREATE INDEX user_sessions_last_accessed_idx ON public.user_sessions(last_accessed_at DESC);
CREATE INDEX user_sessions_active_idx ON public.user_sessions(is_active, expires_at) WHERE is_active = true;

-- Composite indexes for common queries
CREATE INDEX user_sessions_user_active_idx ON public.user_sessions(user_id, is_active, expires_at)
  WHERE is_active = true;
CREATE INDEX user_sessions_cleanup_idx ON public.user_sessions(expires_at, is_active)
  WHERE expires_at < NOW();

-- Enable Row Level Security
ALTER TABLE public.user_sessions ENABLE ROW LEVEL SECURITY;

-- RLS Policies for user sessions
-- Users can view their own sessions
CREATE POLICY "Users can view their own sessions"
  ON public.user_sessions
  FOR SELECT
  USING (user_id = auth.uid());

-- Users can update their own sessions (for extending/revoking)
CREATE POLICY "Users can update their own sessions"
  ON public.user_sessions
  FOR UPDATE
  USING (user_id = auth.uid());

-- Service role can manage all sessions
CREATE POLICY "Service role can manage all sessions"
  ON public.user_sessions
  FOR ALL
  USING (true);

-- Admins can view all sessions
CREATE POLICY "Admins can view all sessions"
  ON public.user_sessions
  FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM public.profiles 
      WHERE id = auth.uid() 
      AND role = 'admin'
    )
  );

-- Function to get expired sessions (used by SessionManager.cleanupExpiredSessions)
CREATE OR REPLACE FUNCTION public.get_expired_sessions()
RETURNS TABLE(id TEXT, user_id UUID, expired_since INTERVAL)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  RETURN QUERY
  SELECT 
    s.id,
    s.user_id,
    NOW() - s.expires_at as expired_since
  FROM public.user_sessions s
  WHERE s.expires_at < NOW()
    AND s.is_active = true
  ORDER BY s.expires_at ASC;
END;
$$;

-- Function to cleanup expired sessions (used by SessionManager.cleanupExpiredSessions)
CREATE OR REPLACE FUNCTION public.cleanup_expired_sessions()
RETURNS INTEGER
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  deleted_count INTEGER;
  session_record RECORD;
BEGIN
  deleted_count := 0;
  
  -- Log each expired session before deletion
  FOR session_record IN 
    SELECT id, user_id, user_email, expires_at
    FROM public.user_sessions
    WHERE expires_at < NOW() - INTERVAL '1 hour' -- Keep for 1 hour after expiry
  LOOP
    -- Create audit log for expired session
    PERFORM public.create_audit_log(
      'session_expired',
      'delete',
      'auth',
      'system',
      NULL,
      NULL,
      NULL,
      'user_session',
      session_record.id,
      jsonb_build_object(
        'user_id', session_record.user_id,
        'user_email', session_record.user_email,
        'expired_at', session_record.expires_at
      ),
      NULL,
      'success',
      'Session expired and cleaned up',
      NULL,
      NULL,
      'auth',
      'cleanup_expired_sessions'
    );
    
    deleted_count := deleted_count + 1;
  END LOOP;
  
  -- Delete expired sessions
  DELETE FROM public.user_sessions
  WHERE expires_at < NOW() - INTERVAL '1 hour';
  
  -- Log cleanup summary
  IF deleted_count > 0 THEN
    PERFORM public.create_audit_log(
      'session_cleanup',
      'delete',
      'system',
      'system',
      NULL,
      NULL,
      NULL,
      'user_session',
      'batch',
      jsonb_build_object('deleted_count', deleted_count),
      NULL,
      'success',
      'Cleanup completed: ' || deleted_count || ' expired sessions removed',
      NULL,
      NULL,
      'auth',
      'cleanup_expired_sessions'
    );
  END IF;
  
  RETURN deleted_count;
END;
$$;

-- Function to revoke session (used by SessionManager)
CREATE OR REPLACE FUNCTION public.revoke_user_session(
  p_session_id TEXT,
  p_reason TEXT DEFAULT 'manual_revocation'
)
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  session_record RECORD;
  revoked BOOLEAN := false;
BEGIN
  -- Get session details before revocation
  SELECT id, user_id, user_email, is_active
  INTO session_record
  FROM public.user_sessions
  WHERE id = p_session_id;
  
  IF FOUND AND session_record.is_active THEN
    -- Revoke the session
    UPDATE public.user_sessions
    SET 
      is_active = false,
      revoked_at = NOW(),
      revoked_reason = p_reason
    WHERE id = p_session_id;
    
    -- Log session revocation
    PERFORM public.create_audit_log(
      'session_revoked',
      'update',
      'auth',
      COALESCE(auth.uid()::text, 'system'),
      COALESCE(auth.email(), session_record.user_email),
      NULL,
      'user_session',
      p_session_id,
      jsonb_build_object(
        'user_id', session_record.user_id,
        'user_email', session_record.user_email,
        'reason', p_reason
      ),
      NULL,
      'success',
      'Session revoked: ' || p_reason,
      NULL,
      NULL,
      'auth',
      'revoke_user_session'
    );
    
    revoked := true;
  END IF;
  
  RETURN revoked;
END;
$$;

-- Function to revoke all user sessions (used for security)
CREATE OR REPLACE FUNCTION public.revoke_all_user_sessions(
  p_user_id UUID,
  p_reason TEXT DEFAULT 'security_revocation'
)
RETURNS INTEGER
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  revoked_count INTEGER;
  user_email_val TEXT;
BEGIN
  -- Get user email for logging
  SELECT email INTO user_email_val
  FROM auth.users
  WHERE id = p_user_id;
  
  -- Revoke all active sessions for the user
  UPDATE public.user_sessions
  SET 
    is_active = false,
    revoked_at = NOW(),
    revoked_reason = p_reason
  WHERE user_id = p_user_id
    AND is_active = true;
  
  GET DIAGNOSTICS revoked_count = ROW_COUNT;
  
  -- Log bulk session revocation
  IF revoked_count > 0 THEN
    PERFORM public.create_audit_log(
      'sessions_bulk_revoked',
      'update',
      'security',
      COALESCE(auth.uid()::text, 'system'),
      COALESCE(auth.email(), user_email_val),
      NULL,
      'user_session',
      'bulk:' || p_user_id::text,
      jsonb_build_object(
        'user_id', p_user_id,
        'user_email', user_email_val,
        'revoked_count', revoked_count,
        'reason', p_reason
      ),
      NULL,
      'success',
      'Bulk session revocation: ' || revoked_count || ' sessions revoked for security',
      NULL,
      NULL,
      'auth',
      'revoke_all_user_sessions'
    );
  END IF;
  
  RETURN revoked_count;
END;
$$;

-- Grant execute permissions
GRANT EXECUTE ON FUNCTION public.get_expired_sessions TO service_role;
GRANT EXECUTE ON FUNCTION public.cleanup_expired_sessions TO service_role;
GRANT EXECUTE ON FUNCTION public.revoke_user_session TO authenticated;
GRANT EXECUTE ON FUNCTION public.revoke_user_session TO service_role;
GRANT EXECUTE ON FUNCTION public.revoke_all_user_sessions TO service_role;

-- Create view for active sessions (used by admin interface)
CREATE OR REPLACE VIEW public.active_user_sessions AS
SELECT 
  s.id,
  s.user_id,
  s.user_email,
  s.user_role,
  s.created_at,
  s.expires_at,
  s.last_accessed_at,
  s.ip_address,
  s.user_agent,
  EXTRACT(EPOCH FROM (s.expires_at - NOW())) as seconds_until_expiry,
  EXTRACT(EPOCH FROM (NOW() - s.last_accessed_at)) as seconds_since_last_access
FROM public.user_sessions s
WHERE s.is_active = true
  AND s.expires_at > NOW()
ORDER BY s.last_accessed_at DESC;

-- Grant access to the view
GRANT SELECT ON public.active_user_sessions TO authenticated;

-- Create trigger for updated_at on user_sessions table
CREATE TRIGGER user_sessions_updated_at
  BEFORE UPDATE ON public.user_sessions
  FOR EACH ROW
  EXECUTE FUNCTION public.handle_updated_at();

-- Create trigger to auto-revoke expired sessions on access
CREATE OR REPLACE FUNCTION public.auto_revoke_expired_sessions()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
  -- If session is being accessed but is expired, revoke it
  IF NEW.last_accessed_at > OLD.last_accessed_at 
     AND NEW.expires_at < NOW() 
     AND NEW.is_active = true THEN
    
    NEW.is_active := false;
    NEW.revoked_at := NOW();
    NEW.revoked_reason := 'auto_expired';
    
    -- Log auto-revocation
    PERFORM public.create_audit_log(
      'session_auto_expired',
      'update',
      'system',
      'system',
      NULL,
      NULL,
      NULL,
      'user_session',
      NEW.id,
      jsonb_build_object(
        'user_id', NEW.user_id,
        'user_email', NEW.user_email,
        'expired_at', NEW.expires_at
      ),
      NULL,
      'success',
      'Session auto-revoked due to expiration',
      NULL,
      NULL,
      'auth',
      'auto_revoke_expired_sessions'
    );
  END IF;
  
  RETURN NEW;
END;
$$;

CREATE TRIGGER auto_revoke_expired_sessions_trigger
  BEFORE UPDATE ON public.user_sessions
  FOR EACH ROW
  EXECUTE FUNCTION public.auto_revoke_expired_sessions();